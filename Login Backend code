1)package.json
{
  "name": "aadhaar-kyc-backend",
  "version": "1.0.0",
  "description": "Express + MongoDB backend for Aadhaar KYC Portal",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "bcrypt": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.0",
    "express": "^4.18.2",
    "express-rate-limit": "^6.7.0",
    "helmet": "^7.0.0",
    "jsonwebtoken": "^9.0.0",
    "mongoose": "^7.0.0",
    "validator": "^13.9.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}

2) .env.example
PORT=5000
MONGO_URI=mongodb://localhost:27017/aadhaar_kyc_db
JWT_SECRET=replace_with_a_long_random_secret
JWT_EXPIRES_IN=7d
BCRYPT_SALT_ROUNDS=12


3) server.js (entrypoint)
require('dotenv').config();
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const mongoose = require('mongoose');
const authRoutes = require('./routes/auth');
const pincodeRoutes = require('./routes/pincode');

const app = express();
const PORT = process.env.PORT || 5000;

// Basic security middlewares
app.use(helmet());
app.use(express.json());

// CORS - allow your frontend origin(s)
app.use(cors({
  origin: ['http://localhost:5500', 'http://127.0.0.1:5500'] // update with your frontend origin(s)
}));

// Rate limiting (basic)
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 200
});
app.use(limiter);

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/pincode', pincodeRoutes);

app.get('/', (req, res) => res.send('Aadhaar KYC Backend is running'));

// Connect to MongoDB and start server
mongoose.connect(process.env.MONGO_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => {
  console.log('Connected to MongoDB');
  app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
})
.catch(err => {
  console.error('MongoDB connection error:', err);
  process.exit(1);
});

4) models/User.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const UserSchema = new Schema({
  aadhaarMasked: { type: String, required: true },      // e.g., ******1234
  aadhaarHash: { type: String, required: true },        // hash of full aadhaar (HMAC or bcrypt)
  mobileNumber: { type: String, required: true },
  uid: { type: String, required: true, unique: true },  // generated UID (your frontend logic)
  passwordHash: { type: String, required: true },
  pincode: { type: String, required: true },
  sector: { type: String },
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('User', UserSchema);

5) routes/auth.js
const express = require('express');
const router = express.Router();
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const validator = require('validator');
const User = require('../models/User');

const SALT_ROUNDS = parseInt(process.env.BCRYPT_SALT_ROUNDS || '12', 10);
const JWT_SECRET = process.env.JWT_SECRET || 'secret';

// Helper: mask aadhaar
function maskAadhaar(aadhaar) {
  return '******' + aadhaar.slice(-4);
}

/**
 * POST /api/auth/signup
 * body: { aadharNumber, mobileNumber, password, uid, pincode, sector }
 */
router.post('/signup', async (req, res) => {
  try {
    const { aadharNumber, mobileNumber, password, uid, pincode, sector } = req.body;

    // Basic validations
    if (!/^\d{12}$/.test(aadharNumber)) return res.status(400).json({ message: 'Invalid Aadhaar number' });
    if (!/^\d{10}$/.test(mobileNumber)) return res.status(400).json({ message: 'Invalid mobile number' });
    if (!uid || typeof uid !== 'string') return res.status(400).json({ message: 'UID missing' });
    if (!pincode || !/^\d{6}$/.test(pincode)) return res.status(400).json({ message: 'Invalid pincode' });
    if (!password || password.length < 8) return res.status(400).json({ message: 'Password must be at least 8 characters' });

    // Password complexity check
    const strong = /(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[^A-Za-z0-9])/;
    if (!strong.test(password)) return res.status(400).json({ message: 'Password must include uppercase, lowercase, number and special character' });

    // Check if UID or mobile exists
    const exists = await User.findOne({ $or: [{ uid }, { mobileNumber }] });
    if (exists) return res.status(409).json({ message: 'User with this UID or mobile already exists' });

    // Hash password and aadhaar (we hash aadhaar to avoid storing plaintext)
    const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);
    const aadhaarHash = await bcrypt.hash(aadharNumber, SALT_ROUNDS);

    const aadhaarMasked = maskAadhaar(aadharNumber);

    const user = new User({
      aadhaarMasked,
      aadhaarHash,
      mobileNumber,
      uid,
      passwordHash,
      pincode,
      sector
    });

    await user.save();

    // Issue JWT (in real system, consider refresh tokens + secure cookie)
    const token = jwt.sign({ id: user._id, uid: user.uid }, JWT_SECRET, { expiresIn: process.env.JWT_EXPIRES_IN || '7d' });

    return res.status(201).json({
      message: 'Account created',
      user: { uid: user.uid, mobileNumber: user.mobileNumber, pincode: user.pincode, sector: user.sector },
      token
    });

  } catch (err) {
    console.error(err);
    return res.status(500).json({ message: 'Server error' });
  }
});

/**
 * POST /api/auth/login
 * body: { aadharNumber, password } OR { uid, password }
 */
router.post('/login', async (req, res) => {
  try {
    const { aadharNumber, uid, password } = req.body;
    if (!password) return res.status(400).json({ message: 'Password required' });

    let user;
    if (uid) {
      user = await User.findOne({ uid });
    } else if (aadharNumber) {
      // find by aadhaarHash - since hashing salts we can't re-query directly; instead search by masked last 4 digits + then compare hash
      const masked = '******' + aadharNumber.slice(-4);
      user = await User.findOne({ aadhaarMasked: masked });
    } else {
      return res.status(400).json({ message: 'Provide uid or aadharNumber' });
    }

    if (!user) return res.status(401).json({ message: 'Invalid credentials' });

    // If login by aadhaarNumber, verify hash
    if (aadharNumber) {
      const aadMatch = await bcrypt.compare(aadharNumber, user.aadhaarHash);
      if (!aadMatch) return res.status(401).json({ message: 'Invalid credentials' });
    }

    const passwordMatch = await bcrypt.compare(password, user.passwordHash);
    if (!passwordMatch) return res.status(401).json({ message: 'Invalid credentials' });

    const token = jwt.sign({ id: user._id, uid: user.uid }, JWT_SECRET, { expiresIn: process.env.JWT_EXPIRES_IN || '7d' });

    return res.json({
      message: 'Login successful',
      user: { uid: user.uid, mobileNumber: user.mobileNumber, pincode: user.pincode, sector: user.sector },
      token
    });

  } catch (err) {
    console.error(err);
    return res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router;

6) routes/pincode.js (pincode lookup)
const express = require('express');
const router = express.Router();

/**
 * In-memory pincode map. In production keep this in DB or a cache.
 * You can expand this list from your frontend's dataset or a verified source.
 */
const pincodeDatabase = {
  '560001': { sector: 'Bengaluru', pools: ['IT Sector', 'Education', 'Healthcare'] },
  '560002': { sector: 'Bengaluru', pools: ['Manufacturing', 'Real Estate', 'Logistics'] },
  '570001': { sector: 'Mysore', pools: ['Tourism', 'Handicrafts', 'Silk Industry'] },
  '570002': { sector: 'Mysore', pools: ['Education', 'Agriculture', 'Textiles'] },
  '110001': { sector: 'Delhi', pools: ['Government', 'Healthcare', 'Education'] },
  '400001': { sector: 'Mumbai', pools: ['Finance', 'Entertainment', 'Logistics'] },
  '600001': { sector: 'Chennai', pools: ['Automobile', 'IT Sector', 'Healthcare'] }
};

router.get('/:pincode', (req, res) => {
  const { pincode } = req.params;
  if (!/^\d{6}$/.test(pincode)) return res.status(400).json({ message: 'Invalid pincode' });

  const data = pincodeDatabase[pincode];
  if (!data) return res.status(404).json({ message: 'Pincode not found' });

  return res.json({ pincode, ...data });
});

module.exports = router;

7) Example middleware/auth.js (optional â€” to secure routes)
const jwt = require('jsonwebtoken');
const JWT_SECRET = process.env.JWT_SECRET || 'secret';

module.exports = (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) return res.status(401).json({ message: 'No token' });

  const token = authHeader.split(' ')[1];
  if (!token) return res.status(401).json({ message: 'No token' });

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Invalid token' });
  }
};

8) How the frontend should call the backend

Update your frontend JS form submission to call the API endpoints. Example fetch for signup:

// inside your handleSignUp (instead of alert + local logic)
const payload = {
  aadharNumber,
  mobileNumber,
  password,
  uid, // your generated uid from frontend
  pincode,
  sector
};

const resp = await fetch('http://localhost:5000/api/auth/signup', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(payload)
});
const data = await resp.json();
if (!resp.ok) {
  alert(data.message || 'Signup failed');
} else {
  // save token in localStorage/session and redirect
  localStorage.setItem('token', data.token);
  alert('Signup success: ' + data.user.uid);
}


And for pincode lookup (you can call when user types 6 digits):

const res = await fetch(`http://localhost:5000/api/pincode/${pincode}`);
if (res.ok) {
  const data = await res.json();
  // use data.sector, data.pools etc.
}
